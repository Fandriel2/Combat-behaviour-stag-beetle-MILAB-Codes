import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import sys
import os

# --- CONFIGURATION ---
# BORIS CSV filename
INPUT_FILENAME = 'Homoderus_gladiator_OvO.csv' 
# ---------------------

def load_and_clean_data(file_path):
    """Loads CSV and cleans column names and behavior labels."""
    if not os.path.exists(file_path):
        print(f"Error: The file '{file_path}' was not found.")
        print("Please make sure the CSV file is in the same folder as this script.")
        sys.exit(1)

    df = pd.read_csv(file_path)
    
    # Clean whitespace from column names
    df.columns = [c.strip() for c in df.columns]
    
    # Merge 'Retreat (Beetle A)' and 'Retreat (Beetle B)' into a single 'Retreat'
    # This simplifies the graph to show the fight ending, regardless of who retreated.
    cols_to_fix = ['Preceding Behaviour', 'Subsequent Behaviour']
    for col in cols_to_fix:
        df[col] = df[col].replace({
            'Retreat (Beetle A)': 'Retreat', 
            'Retreat (Beetle B)': 'Retreat'
        })
        
    return df

def calculate_durations(df):
    """Calculates the duration of each behavior state."""
    # Sort to ensure chronological order per contest
    df = df.sort_values(by=['ContestID', 'Timestamp (s)'])
    
    # Calculate duration by subtracting current timestamp from the NEXT timestamp
    df['Next Timestamp'] = df.groupby('ContestID')['Timestamp (s)'].shift(-1)
    df['Duration'] = df['Next Timestamp'] - df['Timestamp (s)']
    
    # The duration belongs to the 'Subsequent Behaviour' state of the current row
    # (because the row represents the START of that behavior)
    df['Behaviour_State'] = df['Subsequent Behaviour']
    
    # Filter for valid durations (drops the final 'Retreat' step which has no end time)
    df_durations = df.dropna(subset=['Duration']).copy()
    
    return df_durations

def get_transitions_matrix(df):
    """Generates the adjacency matrix and transition probabilities."""
    # Filter out rows where the fight has already ended (Preceding = Retreat)
    df_analysis = df[df['Preceding Behaviour'] != 'Retreat'].copy()
    
    # Get all unique behaviors
    all_behaviours = pd.unique(df_analysis[['Preceding Behaviour', 'Subsequent Behaviour']].values.ravel('K'))
    sorted_behaviours = sorted([b for b in all_behaviours if b != 'Retreat']) + (['Retreat'] if 'Retreat' in all_behaviours else [])
    
    # Create Frequency Matrix
    adj_matrix = pd.crosstab(df_analysis['Preceding Behaviour'], df_analysis['Subsequent Behaviour'])
    adj_matrix = adj_matrix.reindex(index=sorted_behaviours, columns=sorted_behaviours, fill_value=0)
    
    # Clean up matrix (Retreat cannot be a start, Start cannot be an end)
    if 'Retreat' in adj_matrix.index: adj_matrix = adj_matrix.drop('Retreat', axis=0)
    if 'Start' in adj_matrix.columns: adj_matrix = adj_matrix.drop('Start', axis=1)
    
    # Calculate Probability Matrix (Row Sums)
    row_sums = adj_matrix.sum(axis=1)
    # Avoid division by zero
    adj_rate = adj_matrix.apply(lambda row: row / row_sums[row.name] if row_sums[row.name] > 0 else 0, axis=1)
    
    return adj_matrix, adj_rate, df_analysis

def get_significant_transitions(df_analysis, observed_matrix, n_permutations=1000):
    """Performs a permutation test to find non-random transitions."""
    print(f"Running permutation test ({n_permutations} iterations)...")
    
    preceding = df_analysis['Preceding Behaviour'].values
    subsequent = df_analysis['Subsequent Behaviour'].values
    
    # Store null distributions
    perm_dists = { (i, j): [] for i in observed_matrix.index for j in observed_matrix.columns }
    
    np.random.seed(42) # For reproducibility
    for _ in range(n_permutations):
        shuffled_sub = np.random.permutation(subsequent)
        # Create temp matrix
        df_perm = pd.DataFrame({'Preceding': preceding, 'Subsequent': shuffled_sub})
        perm_mat = pd.crosstab(df_perm['Preceding'], df_perm['Subsequent'])
        perm_mat = perm_mat.reindex(index=observed_matrix.index, columns=observed_matrix.columns, fill_value=0)
        
        for i in perm_mat.index:
            for j in perm_mat.columns:
                perm_dists[(i, j)].append(perm_mat.loc[i, j])
                
    # Check significance (Observed > 95th percentile of Null)
    significant_edges = []
    for i in observed_matrix.index:
        for j in observed_matrix.columns:
            obs_val = observed_matrix.loc[i, j]
            if obs_val > 0:
                threshold = np.percentile(perm_dists[(i, j)], 95)
                if obs_val > threshold:
                    significant_edges.append((i, j))
                    
    return significant_edges

def plot_ethogram(G, pos, node_labels, node_sizes, edge_labels, widths, prop_dict):
    """Draws the network graph and the side bar chart."""
    fig = plt.figure(figsize=(18, 10))
    gs = gridspec.GridSpec(1, 2, width_ratios=[3, 1]) 

    # --- Plot 1: The Network Graph ---
    ax0 = plt.subplot(gs[0])
    
    # Draw Nodes
    nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color='lightblue', edgecolors='black', ax=ax0)
    # Draw Edges
    nx.draw_networkx_edges(G, pos, width=widths, arrowstyle='-|>', arrowsize=20, connectionstyle='arc3,rad=0.1', ax=ax0)
    # Labels
    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=9, font_weight='bold', ax=ax0)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, label_pos=0.7, font_color='red', font_weight='bold', ax=ax0)
    
    ax0.set_title("Stag Beetle Combat Ethogram\n(Node Size = Time Spent | Red Numbers = Transition Probability)", fontsize=14)
    ax0.axis('off')

    # --- Plot 2: The Time Budget Bar Chart ---
    ax1 = plt.subplot(gs[1])
    
    # Sort data for bar chart
    sorted_props = sorted(prop_dict.items(), key=lambda x: x[1], reverse=True)
    labels = [x[0] for x in sorted_props if x[0] != 'Retreat' and x[0] != 'Start']
    values = [x[1] for x in sorted_props if x[0] != 'Retreat' and x[0] != 'Start']
    
    y_pos = np.arange(len(labels))
    ax1.barh(y_pos, values, align='center', color='skyblue', edgecolor='black')
    ax1.set_yticks(y_pos)
    ax1.set_yticklabels(labels)
    ax1.invert_yaxis() 
    ax1.set_xlabel('Proportion of Total Fight Time')
    ax1.set_title('Time Budget (Breakdown of 1)')
    ax1.set_xlim(0, max(values)*1.3) # Extra space for text

    # Add percentage text
    for i, v in enumerate(values):
        ax1.text(v + 0.005, i, f"{v:.1%}", va='center', fontweight='bold')

    plt.tight_layout()
    plt.savefig('ethogram_results.png')
    print("Graph saved as 'ethogram_results.png'")
    plt.show()

def main():
    print(f"Loading data from {INPUT_FILENAME}...")
    df = load_and_clean_data(INPUT_FILENAME)
    
    # 1. Time Budget Analysis
    df_durations = calculate_durations(df)
    total_time = df_durations['Duration'].sum()
    behavior_durations = df_durations.groupby('Behaviour_State')['Duration'].sum()
    prop_dict = (behavior_durations / total_time).to_dict()
    
    print("\n--- Time Budget (Breakdown of 1) ---")
    for b, p in prop_dict.items():
        print(f"{b}: {p:.2%}")
        
    # 2. Transition Analysis
    adj_matrix, adj_rate, df_analysis = get_transitions_matrix(df)
    significant_edges = get_significant_transitions(df_analysis, adj_matrix)
    
    print(f"\nFound {len(significant_edges)} significant behavioral transitions.")

    # 3. Build Graph
    G = nx.DiGraph()
    
    # Add Nodes (Sized by proportion)
    nodes = [b for b in adj_matrix.columns if b != 'Start']
    node_sizes = []
    node_labels = {}
    
    for n in nodes:
        G.add_node(n)
        prop = prop_dict.get(n, 0.0)
        node_sizes.append(1500 + (prop * 8000)) # Base size + scaling
        node_labels[n] = f"{n}\n({prop:.1%})"
        
    # Add Edges (Weighted by probability)
    edge_labels = {}
    widths = []
    
    for u, v in significant_edges:
        if u != 'Start' and v != 'Start':
            prob = adj_rate.loc[u, v]
            G.add_edge(u, v)
            edge_labels[(u, v)] = f"{prob:.2f}"
            widths.append(1 + prob * 3)
            
    # Layout
    pos = nx.spring_layout(G, k=2.5, seed=42)
    
    # Plot
    plot_ethogram(G, pos, node_labels, node_sizes, edge_labels, widths, prop_dict)

if __name__ == "__main__":
    main()
